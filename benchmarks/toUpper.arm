/* Test of ToUpper function, that converts a string to all uppercase.

C Implementation:

char string[] = { <initialization data };
char *index = string;
while (*index != 0) { /* C strings end in 0 */
  if (*index >= 'a' && *index <= 'z')
  *index = *index +('A' - 'a');
  index++;
}
// Hash the results to make sure it is right
int hash = 0;
while (index >= string) {
  hash = 2*hash + (*index);
  index--;
}

Requires:
	ADDI, ADDS, B, B.LT, CBZ, LDURB, MOVK, MOVZ, STUR, STURB, SUBS

Expected results:
	X0  = 80 (address of the string array)
	X1  = 79 (X0-1)
	X2  = 97 (ASCII 'a')
	X3  = 122 (ASCII 'z')
	X4  = 32 ('a' - 'A')
	X5  = Lab 3: 87 (first character in upper-case string), Lab 4: X (character before the string) due to delay slot
	X7  = 114028278768209169 (hash of upper-case string)
	X8  = 1  (used for decrementing)
	Mem[80 to 133] The message, in all upper case.
*/

// MAIN:
1001000100_000001010000_11111_00000	//000: ADDI X0, X31, #80	// XO: string, starts at address 80.
110100101_00_0110111101010111_00001	//004: MOVZ X1, #0x6f57, LSL 0	// Initialize memory with a sample string.
111100101_01_0010110001110111_00001	//008: MOVK X1, #0x2c77, LSL 16
111100101_10_0111100100100000_00001	//012: MOVK X1, #0x7920, LSL 32
111100101_11_0111010101101111_00001	//016: MOVK X1, #0x756f, LSL 48
11111000000_000000000_00_00000_00001	//020: STUR X1, [X0, #0]
110100101_00_0110000100100000_00001	//024: MOVZ X1, #0x6120, LSL 0
111100101_01_0111010001100011_00001	//028: MOVK X1, #0x7463, LSL 16
111100101_10_0110000101110101_00001	//032: MOVK X1, #0x6175, LSL 32
111100101_11_0110110001101100_00001	//036: MOVK X1, #0x6c6c, LSL 48
11111000000_000001000_00_00000_00001	//040: STUR X1, [X0, #8]
110100101_00_0010000001111001_00001	//044: MOVZ X1, #0x2079, LSL 0
111100101_01_0111001001110100_00001	//048: MOVK X1, #0x7274, LSL 16
111100101_10_0110111001100001_00001	//052: MOVK X1, #0x6e61, LSL 32
111100101_11_0110110001110011_00001	//056: MOVK X1, #0x6c73, LSL 48
11111000000_000010000_00_00000_00001	//060: STUR X1, [X0, #16]
110100101_00_0111010001100001_00001	//064: MOVZ X1, #0x7461, LSL 0
111100101_01_0110010001100101_00001	//068: MOVK X1, #0x6465, LSL 16
111100101_10_0110000100100000_00001	//072: MOVK X1, #0x6120, LSL 32
111100101_11_0110110001101100_00001	//076: MOVK X1, #0x6c6c, LSL 48
11111000000_000011000_00_00000_00001	//080: STUR X1, [X0, #24]
110100101_00_0110111100100000_00001	//084: MOVZ X1, #0x6f20, LSL 0
111100101_01_0010000001100110_00001	//088: MOVK X1, #0x2066, LSL 16
111100101_10_0110100001110100_00001	//092: MOVK X1, #0x6874, LSL 32
111100101_11_0111001101101001_00001	//096: MOVK X1, #0x7369, LSL 48
11111000000_000100000_00_00000_00001	//100: STUR X1, [X0, #32]
110100101_00_0010000000111111_00001	//104: MOVZ X1, #0x203f, LSL 0
111100101_01_0110100101001110_00001	//108: MOVK X1, #0x694e, LSL 16
111100101_10_0110010101100011_00001	//112: MOVK X1, #0x6563, LSL 32
111100101_11_0110101000100000_00001	//116: MOVK X1, #0x6a20, LSL 48
11111000000_000101000_00_00000_00001	//120: STUR X1, [X0, #40]
110100101_00_0110001001101111_00001	//124: MOVZ X1, #0x626f, LSL 0
111100101_01_0000000000100001_00001	//128: MOVK X1, #0x0021, LSL 16
11111000000_000110000_00_00000_00001	//132: STUR X1, [X0, #48]
1001000100_000000000000_00000_00001	//136: ADDI X1, X0, #0		// X1: char *index = string;
1001000100_000001100001_11111_00010	//140: ADDI X2, X31, #97	// X2: 'a'
1001000100_000001111010_11111_00011	//144: ADDI X3, X31, #122	// X3: 'z'
1001000100_000000100000_11111_00100	//148: ADDI X4, X31, #32	// X4: ('a' - 'A')
1001000100_000000000001_11111_01000	//152: ADDI X8, X31, #1		// X8: 1, for decrement.
// WHILE_TOP:
00111000010_000000000_00_00001_00101	//156: LDURB X5, [X1, #0]	// X5: *index, the character.
1001000100_000000000000_11111_11111	//160: ADDI X31, X31, #0	// NOOP
10110100_0000000000000001001_00101	//164: CBZ X5, WHILE_DONE	// while (*index != 0) { /* C strings end in 0 */
11101011000_00010_000000_00101_11111	//168: SUBS X31, X5, X2		// is *index < 'a'?
01010100_0000000000000000101_01011	//172: B.LT NOT_LOWER_CASE
11101011000_00101_000000_00011_11111	//176: SUBS X31, X3, X5		// is 'z' < *index?
01010100_0000000000000000011_01011	//180: B.LT NOT_LOWER_CASE
11101011000_00100_000000_00101_00110	//184: SUBS X6, X5, X4		// X6: *index - ('a'-'A')
00111000000_000000000_00_00001_00110	//188: STURB X6, [X1, #0]	// Update the string, since is lower case.
// NOT_LOWER_CASE:
1001000100_000000000001_00001_00001	//192: ADDI X1, X1, #1		// index++;
000101_11111111111111111111110110	//196: B WHILE_TOP		// continue the loop.
// WHILE_DONE:			// Hash the results to make sure it is right
1001000100_000000000000_11111_00111	//200: ADDI X7, X31, #0		// X7: int hash = 0;
// HASH_TOP:
11101011000_00000_000000_00001_11111	//204: SUBS X31, X1, X0		// is index < string?
01010100_0000000000000000111_01011	//208: B.LT HASH_DONE		// while (index >= string) {
00111000010_000000000_00_00001_00101	//212: LDURB X5, [X1, #0]	//   get *index
10101011000_00111_000000_00111_00111	//216: ADDI X7, X7, X7		//  hash *= 2
10101011000_00101_000000_00111_00111	//220: ADDI X7, X7, X5		//  hash += (*index)
11101011000_01000_000000_00001_00001	//224: SUBS X1, X1, X8		//   index--;
000101_11111111111111111111111010	//228: B HASH_TOP		// }
1001000100_000000000000_11111_11111	//232: ADDI X31, X31, #0	// NOOP
// HASH_DONE:
000101_00000000000000000000000000	//236: B HASH_DONE		// Loop forever
1001000100_000000000000_11111_11111	//240: ADDI X31, X31, #0	// NOOP
